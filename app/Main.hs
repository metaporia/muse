{-# LANGUAGE GADTSyntax, GADTs, InstanceSigs, ScopedTypeVariables,
   OverloadedStrings #-}
module Main where

import           Control.Monad (void)
import           Data.Aeson hiding (Null)
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import           Data.List (isInfixOf, sort, intercalate)
import           Data.Maybe (catMaybes)
import           Data.Monoid ((<>))
import qualified Data.Text as T
import qualified Data.Text.IO as T
import           Data.Time
import           Data.Time.Calendar
import           Data.Time.Clock (utctDay)
import           Data.Yaml.Config (load, lookup, lookupDefault, subconfig)
import           Helpers
import           Lib
import           Options.Applicative
import           Parse
import           Prelude hiding (lookup, log, init)
import           Search
import           System.Directory (doesFileExist, createDirectoryIfMissing, listDirectory, getModificationTime)
import           System.Environment (getEnv)
import qualified Text.Trifecta.Result as Tri

-- Questions:
--
-- * default date span?
-- * 
-- Flags:
--
-- * --after DATE, --before DATE: month, day, year
--
--   N.B: --since, --until are valid alternatives
--
--    * DATE:
--
--        - configurable date format. my personal default is day/month/year
--        - when a date attribute, e.g., day, month, or year, is omitted, the
--          that of the current date is used
--
--        - relative dates: 
--
--           --relative <rdate>
--           <rdate> : (order agnostic, all but one field is optional) 'NNdNNmNNy', 
--                     e.g., '1m', '2m3d', '3d1m2y'.
--
--
--
-- * --filter (author | title | definition)
--
-- muse [(--within | -w) relDATE ] [(--author | -a) AUTHOR] 
--      ([(--title | -t) TITLE] [--definitions | -d] | [(--quotation | -q) [SEARCH_STRING]])
--
-- For instance, 'muse -w 5d3m2y'
-- TODO
-- □  relative date parser
-- | Reads `RelDur`.
-- (order agnostic, all but one field is optional) 'NNdNNmNNy', 
--          e.g., '1m', '2m3d', '3d1m2y'.
--
-- N.B.: ordered parsing on first pass
relDurReader :: ReadM RelDur
relDurReader =
  eitherReader $ \s ->
    case parse relDur s of
      Tri.Success rd -> Right rd
      Tri.Failure err ->
        Left $
        "Cannot parse relative date by (dmy): " ++
        s ++ "\nErrInfo: " ++ show err
  -- d m y
  -- y m d
  -- m d y

-- | Contains filters, either entry predicates or projections, including:
--
-- * filter by author match
-- * filter by title match
-- * filter within date
-- * map definition extraction 
-- * map quotation extraction
--
-- Of the above, filters will be applied (in arbitrary order, a.t.m.) to log
-- entries, after which map will be applied to the remainder.
--
-- A `Search` instance will be generated by the 
data DateTime =
  DateTime


-- | Convert duration, combined with the system time, into UTC time. See the
-- `time` library.
--
-- TODO: handle d/m/y excess w/ rollover
subRelDur :: Day -> RelDur -> Day
subRelDur day (RelDur y m d) =
  addGregorianYearsRollOver (negate y) .
  addGregorianMonthsRollOver (negate m) . addDays (negate d) $
  day

search :: Day -> Parser Input
search today = Input <$> (subRelDur today 
                     <$> within) 
                     <*> pure today 
                     <*> (fmap isInfixOf <$> author)
                     <*> (fmap isInfixOf <$> title)
                     <*> defs
                     <*> quotes

data InputType
  = File FilePath
  | StdIn String
  | All -- ^ Parse all entries in `entrySource`
        Bool -- ^ Silence errors?
        Bool -- ^ Ignore parsed entry cache?
  deriving (Eq, Show)

-- | A bare invocation will default to `parse --all --ignore-cache`, which
-- parses all entries, uses parsed entry cache, and displays parse errors.
parse' :: Parser InputType
parse' =
  File <$> fileInput <|> StdIn <$> stdInput <|> allEntries <|>
  pure (All False False)

allEntries :: Parser InputType
allEntries =
  (\_ s i -> All s i) <$>
  switch
    (long "all" <> short 'a' <>
     help "Parse all entries in 'log-dir' (see ~/.muse/config.yaml)") <*>
  quiet <*>
  ignore

stdInput :: Parser String
stdInput =
  option
    str
    (metavar "LOG_CONTENT" <> long "stdin" <> short 's' <>
     help "Parse from stdin") <**>
  helper

fileInput :: Parser FilePath
fileInput =
  option
    str
    (long "file" <> metavar "FILE" <> help "Read in log from file" <> short 'f') <**>
  helper

init :: Parser Invocation
init = Init <$> quiet <*> ignore

quiet :: Parser Bool
quiet =
  switch
    (long "quiet" <> short 'q' <> help "Suppress log parser error messages")

ignore :: Parser Bool
ignore =
  switch
    (long "ignore-cache" <> short 'i' <>
     help "Reparse all entries, ignore cache (overwrites cache)")

toplevel :: Day -> Parser Invocation
toplevel today =
  subparser
    (command
       "search"
       (info
          (Search <$> search today <**> helper)
          (progDesc
             "Search log entries by date, author, or title; extract\
              \ definitions or quotations.")) <>
     command
       "parse"
       (info
          (Parse <$> parse' <**> helper)
          (progDesc "Parse entries; a bare invocation runs 'parse --all'")) <>
     command
       "lint"
       (info
          (pure Lint)
          (progDesc "TBD; for, e.g., author attribution validation")) <>
     command
       "init"
       (info
          (init <**> helper)
          (progDesc
             "Initialize config file, cache directory, and entry log\
             \ directory; parse all entries in 'log-dir'")))

data Invocation
  = Search Input
  | Parse InputType
  | Lint
  | Init Bool -- ^ Suppress log parse errors
         Bool -- ^ Reparse cached entries
defs :: Parser Bool
defs = switch $ long "definitions" 
  <> short 'd' 
  <> help "Collect definitions of left-over entries."

quotes :: Parser Bool
quotes = switch $ long "quotations" 
  <> short 'q' 
  <> help "Collect quotations of remaining entries."

entryToSearchResult :: Entry -> SearchResult
entryToSearchResult (Def dq) = Def' (show dq)
entryToSearchResult (Quotation b attr pg) = Quotation' b attr pg
entryToSearchResult (Read t a) = Read' t a
entryToSearchResult (Commentary s) = Commentary' s
entryToSearchResult (PN pg) = PN' pg
entryToSearchResult Null = Null'

author :: Parser String
author =
  strOption
    (long "author" 
    <> metavar "SUBSTR"
    <> short 'a' <> value "" <> help "Substring/affix of author")

title :: Parser String
title =
  strOption 
    (long "title" 
    <> metavar "SUBSTR"
    <> short 't' <> value "" <> help "Affix of title")

within :: Parser RelDur
within =
  option
    relDurReader
    (long "within" 
    <> metavar "REL_DATE"
    <> help "Lower bound of search filter range" <>
     short 'w' <>
     value (RelDur 0 6 0))

main' :: IO ()
main' =
  loadMuseConf >>= parseAllEntries True False

main :: IO ()
main = do
  today <- utctDay <$> getCurrentTime
  execParser (info (helper <*> toplevel today) (fullDesc <> header "dispatch")) >>=
    dispatch

main'' :: IO ()
main'' = do
  today <- utctDay <$> getCurrentTime
  let opts =
        info
          (helper <*> search today)
          (fullDesc <> progDesc "Run logParse search filters." <>
           header "muse - a reading log search interface")
  execParser opts >>= runSearch 

dispatch :: Invocation -> IO ()
dispatch (Search inp) = putStrLn "searching...\n" >> runSearch inp
dispatch (Lint) = putStrLn "linting"
dispatch (Init quiet ignoreCache) = do
  putStrLn  "initializing...\n" -- ++ showMuseConf mc
  void $ museInit quiet ignoreCache
dispatch (Parse it) = do
  mc <- loadMuseConf
  putStrLn  "parsing..."
  s <- case it of
      File fp -> readFile fp
      StdIn s -> return s
      All silence ignore -> parseAllEntries silence ignore mc >> return ""
  putStrLn s

-- | As yet, this searches only pre-parsed `LogEntry`s.
runSearch :: Input -> IO () 
runSearch input@(Input s e tp ap dfs qts) = do
  let dateFilter = do
        mc <- loadMuseConf
        fps <- listDirectory . T.unpack $ entryCache mc
        dates <- filterBy s e <$> pathsToDays fps
        let cachePath = (T.unpack (entryCache mc) ++)
            entries =
              loadFiles (cachePath . dayToPath <$> dates) >>=
              return . catMaybes . decodeEntries
              -- TODO print date above each days `[LogEntry]`
            filtered = fmap (filterWith input) <$> entries
        return filtered

  filtered <- join dateFilter
  putStrLn $
    "start date: " ++
    show s ++
    "\n" ++
    "end date: " ++
    show e ++
    "\ncollect defs: " ++
    show dfs ++
    "\ncollect quotations: " ++
    show qts ++
    "\nfancy search magick!" ++
    "\nfiltered dates (to be searched):\n" ++ show filtered


-- config
data MuseConf = MuseConf
  { log :: T.Text -- ^ * "$HOME/.muse/entries
  , cache :: T.Text
  , home :: T.Text
  } deriving (Eq, Show)

entryCache :: MuseConf -> T.Text
entryCache (MuseConf _ cache _) = cache <> "parsedEntries/"

entrySource :: MuseConf -> T.Text
entrySource = log

config :: MuseConf -> T.Text
config mc = home mc <> "/.muse/config.yaml"


-- | Expects config at  $HOME/.muse/config.yaml
loadMuseConf :: IO MuseConf
loadMuseConf = do
  home' <- getEnv "HOME"
  config <- load $ home' ++ "/.muse/config.yaml"
  let home = T.pack home'
      logDef = home <> "/.muse/entries/"
      cacheDef = home `T.append` "/.cache/muse/"
      -- lookup
      logDir = lookupDefault "log-dir" logDef config
      cacheDir = lookupDefault "cache-dir" cacheDef config
  mapM_ T.putStrLn ["muse config: ", logDir, cacheDir]
  return $ MuseConf logDir cacheDir home


showMuseConf :: MuseConf -> String
showMuseConf = show

writeMuseConf :: MuseConf -> IO MuseConf
writeMuseConf mc = do
  let conf = "log-dir: " <> (entrySource mc) <> "\n\ncache-dir: " <> entryCache mc
  createDirectoryIfMissing True $ T.unpack  (home mc <> "/.muse")
  T.writeFile (T.unpack $ config mc) conf
  return mc


-- muse init:
-- 1. prompt for config file creation, default at ~/.muse
-- 2. check whether (a) logDir and (b) cacheDir exist.
--    i.  if both (a) and (b) hold, then proceed to (3)
--    ii. otherwise prompt for missing locations, write choices to ~/.muse
-- 3. parse log dir; serialize successful results ([Int, TS, Entry]) to
--    cacheDir/entries (bucket by month); collect filenames of parse failures 
--    into cacheDir/failures. 
--
--    -  write valid date range to config ?
--    TODO tag generation based on entry grouping
-- 4. 


-- | Prompt user for log dir, cache dir, 
prompt :: IO MuseConf
prompt = do
  home' <- getEnv "HOME"
  let home = T.pack home'
      defConfPath = home <> "/.muse"
      defCacheDir = home <> "/.cache/muse"
  T.putStr $ "Enter path to entry directory (default: " <> defConfPath <> "/entries/): "
  resp <- T.getLine
  let entryDir :: T.Text
      entryDir =
        case resp of
          "" -> defConfPath <> "/entries"
          _ -> resp
  T.putStr $ "Enter path to cache directory (default: " <> defCacheDir <> "): "
  resp <- T.getLine
  let cacheDir =
        case resp of
          "" -> defCacheDir
          _ -> resp
      conf = MuseConf entryDir defConfPath cacheDir
  writeMuseConf conf



-- | Creates ~/.muse/{entries/,config.yaml} and ~/.cache/muse/entries.
--
-- TODO check if file exists before overwriting/tampering with it!!
--
museInit :: Bool -> Bool -> IO MuseConf
museInit quiet ignoreCache = do
  home' <- getEnv "HOME"
  let home = T.pack home'
      defConfPath = home <> "/.muse/config.yaml"
      defConfPath' = T.unpack defConfPath
      defCacheDir = home <> "/.cache/muse/"
      defLogDir = home <> "/.muse/entries/"
      defaults = MuseConf defLogDir defCacheDir home
  T.putStrLn $ "Expects configuration file at: " <> home <> defConfPath <> "\n"
  -- create config & conf dir
  
  doesExist <- doesFileExist defConfPath'
  mc <- if doesExist
           then loadMuseConf
           else writeMuseConf defaults
  createDirectoryIfMissing True . T.unpack $ entryCache mc -- (cache mc) <> "/parsedEntries"
  T.putStrLn $ entryCache mc <> " and " <> log mc <> " found or created."
  createDirectoryIfMissing True $ T.unpack (log mc)
  parseAllEntries quiet ignoreCache mc
  return mc

-- | Parse all entries from logDir into cacheDir/entries.
-- TODO pass counter through `showErrOrCollect` to tally parse errors
parseAllEntries :: Bool -> Bool -> MuseConf -> IO ()
parseAllEntries quiet ignoreCache mc@(MuseConf log cache home)
  -- read in log file names; parse 'em
 = do
  --putStrLn $ show mc
  fps <- sort <$> lsEntrySource mc
  -- 
  let selectModified :: [FilePath] -> IO [FilePath]
      -- | Check, if for a given log file a parsed file has been cached, 
      --   whether the log's modification date is greater than the that of the 
      --   cached json.
      selectModified fps = 
        if ignoreCache 
           then putStrLn "ignoring parsed entry cache" >> return fps
           else foldr
          (\fp rest -> do
            -- check for cache existence
             existsCache <- doesFileExist $ T.unpack (entryCache mc) ++ fp
             if existsCache
                then do -- compare cache and log modification times
                  logMd <- getModificationTime $ T.unpack (entrySource mc) ++ fp
                  cacheMd <- getModificationTime $ T.unpack (entryCache mc) ++ fp
                  if cacheMd >= logMd
                     then (fp :) <$> rest
                     else rest
                else rest)
          (return []) fps

      parse :: String -> IO (String, Either String [LogEntry])
      parse fp =
        (,) <$> pure fp <*>
        (showErr . parseByteString logEntries mempty <$>
         B.readFile (T.unpack (entrySource mc) ++ "/" ++ fp))

      invert :: (fp, Maybe e) -> Maybe (fp, e)
      invert (fp, me) =
        case me of
          Just e -> Just (fp, e)
          Nothing -> Nothing

      parseAndShowErrs :: [FilePath] -> IO [(String, [LogEntry])]
      parseAndShowErrs fs = sequence (parse <$> fs) >>= showOrCollect
      
      showOrCollect :: [(String, Either String res)] -> IO [(String, res)]
      showOrCollect =
        let sideBar = unlines . fmap ("> " ++) . lines
        in foldr
             (\(fp, e) rest ->
                case e -- render errros w filename, `ErrInfo`
                      of
                  Left err ->
                    if quiet
                      then rest
                      else putStrLn ("File: " ++ fp ++ "\n" ++ sideBar err) >> rest
                  Right res -> ((fp, res) :) <$> rest)
             (return [])

  if quiet then putStrLn "\nSuppressing entry parse error output" else return ()
  entryGroups <- selectModified fps >>= parseAndShowErrs
  sequence_ $
    fmap
      (\(fp, eg) ->
         BL.writeFile (T.unpack (entryCache mc) ++ "/" ++ fp) (encode eg))
      entryGroups


-- TODO 
--
-- □  centralize file path generation--save yourself the headache later of
--    mismatched paths!
-- on parse failure, show user err info
--
parsedEntryDir :: MuseConf -> T.Text
parsedEntryDir = undefined
